---
title: '关于系统性能优化的总结'
date: 2020-06-17 21:05:11
tags: [性能调优]
published: true
hideInList: false
feature: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1592810879330&di=84a8094e31dabae6a1cbe120e32baa9e&imgtype=0&src=http%3A%2F%2Fpcs4.clubstatic.lenovo.com.cn%2Fdata%2Fattachment%2Fforum%2F201610%2F05%2F151814x05lyhh1x0w8519w.jpg
isTop: false
---

### 前言
>   对于任何系统，都会存在系统性能瓶颈，这里笔者作为一名Java工程师列出了自己在工作中的优化思路，仅供参考。

  

## 一、系统性能预测
&emsp;现在服务都是微服务部署开发，如果要模拟服务压测的话要在本地开启相同的服务，前提是机器配置是一样的。而且需要将线上的持久化数据同样copy到本地数据库中，这样才能真正模拟线上的环境。

&emsp;首先拿单台机器进行压测，压测的对象可以是某个核心的接口（这个接口可以是日志服务中统计的访问量比较高的具体的接口API），比如拿金融产品的标下单接口或者产品标的详情接口，像这种接口在某个时间会有一个高并发访问的瞬间流量。

&emsp;具体的指标主要是要分析系统的QPS和TPS，我们预测一个单体的应用能够承受多少的并发量，看这两个指标是否能够达到我们预期的值。后面进行压测时候，观察流量巅峰时刻观察系统的运行情况。以下就性能分析优化展开总结。
<br>

## 二、系统性能分析优化
### 1、硬件方面：
##### CPU：
 &emsp;在压测的时候观察CPU的占用情况，是否长期处于100%状态，正常来说80%以下是正常的。如果非常低，那么说明系统不是在做IO密集型运算动作，性能瓶颈是在其他方面，不是在CPU上面，具体的操作方法可以用top命令查看。
 &emsp;以笔者经验来看，一般CPU飙高的原因无非三种：
 1. 第一种就是代码中存在死循环，并且循环中有大量的CPU计算操作；
 2. 第二种就是多线程并发下，竞争相同的资源导致大量线程获取不到资源，如果此时线程进行自旋操作，不释放CPU资源，那就导致CPU飙升；
 3. 第三种就是代码中有内存泄漏，导致内存一直处于阈值状态，GC线程会持续GC，导致CPU飙高。
   
 &emsp;上面三种情况中第二种和第三种情况在日常开发工作中会遇到，对于第二种情况对于自旋锁情况，一般会用CAS乐观锁去实现，并且设置一定的超时时间和重试次数，然后返回失败或者进入阻塞队列释放CPU分片，防止线程一直占用CPU资源。
 &emsp;对于第三种情况，就是代码的BUG，开发过程中要注意泄漏的问题，就比如多线程操作链表，如果没有做同步的锁，那么很有可能导致链表的引用指针混乱，引起内存泄漏。
 &emsp;以上，如果我们开发工作中避免了上述几种情况，CPU就能够发挥它应该有的能力，提升系统性能。同时，开发人员做好硬件CPU监控是非常有必要的。
##### 内存：
  &emsp; 在Java中，内存JVM是一个很重要的指标，这个关乎到系统是否可以稳定运行。我们可以借助三方工具可以查看系统的JVM内存的运行情况，笔者提供几个通用的预测内存的运行情况的思路：
    - 每秒占用多少内存？
    - 多长时间触发一次Minor GC？
    - 多长时间触发一次Major GC？
    - Minor  GC耗时多久？Major  GC耗时多久？
    - 会不会频繁因为Survivor放不下导致对象进入老年代？
    
在日常开发中，开发人员需要关注的就是，判断系统JVM是否有频繁FULL GC和频繁YOUNG GC，如果有，那么会严重影响系统性能。笔者就这两个方面去分析一下
 &emsp;&emsp; 1、**频繁FULL GC** ：首先我们应该要了解到频繁FULL GC危害，一般的中大型系统，系统的JVM会设置很大，比如会给堆内存分配4~8G的空间，因为遍历对象图的过程中堆越大，遍历时间就会长，而且如果垃圾越多，垃圾回收也会拉长整个GC的时间，这就导致每一次FULL GC会有长时间的STW，影响系统稳定性。然后我们要清楚导致触发Full GC的场景，这里列出了可能会导致的几个场景：
&emsp;&emsp;1）大对象
&emsp;&emsp;2）方法区meta space空间占满
&emsp;&emsp;3）年轻代的存活的生命周期长对象一直汇入老年代，导致GC
&emsp;&emsp;4）内存泄漏导致空间不足进而GC
这里笔者就拿内存泄漏（内存泄漏指的是有引用无法被回收但是没有用的对象持续增长）来说，一般如果有内存泄漏。大概的内存监控图长这个样子![](https://zhangyaoo.github.io/post-images/1592463486063.png)
这样导致的后果就是，频繁的FULL GC，最后内存一直持续增长到爆满，然后FULL GC执行间隔缩短，最终会导致GC线程持续GC，CPU使用率会直线飙升，导致系统瘫痪。
 &emsp;&emsp;  2、 **频繁 YOUNG GC**  ：YOUNG GC如果过于频繁的话，一般是短周期小对象较多，这时候可以从 Eden 区/新生代设置的太小了这个方面考虑，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题
  

  **这里笔者以自己开发经验，提供一些“简单的”JVM优化拙见**：
1. 尽量将新生代的垃圾回收掉，不让存活对象进入老年代，因为老年代的GC代价比年轻代高，这里可以设置分代年龄-XX:MaxTenuringThreshold=XX
&emsp; 例子1：比如说业务上一分钟产生几百兆的数据，而且需要存活一分钟，如果一分钟YGC的次数少于默认分代年龄，那么对象会进去老年代引发FGC，FGC会引起更大的停顿时间
&emsp; 例子2：如果说对象都是一些短期对象，那么可以设置分代年龄更小，因为长期对象肯定是大对象或者单例对象永驻内存的，这样可以腾出空间给新生代GC，避免新生代频繁GC
2. 增加新生代内存的大小，防止导致频繁的minor GC，这样老年代的Major GC频率也会降低
3. 尽量将大内存的服务，拆分成几个相同服务，也就是多实例部署，分散堆内存资源，避免堆大内存导致GC时间过长（这个和G1分区回收思想相似）
4. 每个线程占用的内存不应过大或者过小，不然会导致OOM
&emsp; 如果线程内存过小，会导致线程里面的栈内存小，临时变量如果超出这个阈值就会无法分配栈，导致栈溢出，出现stackoverflow
&emsp; 如果线程内存过大，在多线程并发下，如果线程数量过多，会占用非常多JVM内存，有内存溢出的风险
5. 合理设置垃圾回收器，在大内存或者在内存碎片化环境下，G1垃圾回收器会有很好的效果
&emsp; G1垃圾回收器是Java9默认回收器，G1能够在指定的停顿时间内，根据每个region的回收价值，选择可以去回收的region，并且存活对象移动复制是多线程进行的。这里要注意如果设置停顿时间的话，不能设置太小，因为太小会导致每次进行回收的region太少，导致垃圾回收速度更不上垃圾生产的速度，这样随着时间推移，系统垃圾对象会越来越多，占满JVM
6. 对象生命周期的分布情况：如果应用存在大量的短期对象，应该适当增大年轻代 -Xmn；如果存在相对较多的持久对象，老年代应该适当增大。-Xms -Xmx
7. Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失
8. 设置大对象对象的大小，一般系统中大对象大部分都是一些系统的缓存，像这些对象尽早让它们的进入老年代，避免占用新生代的空间。

以上，合理分配JVM内存资源以及做好系统内存的监控机制是我们系统稳定性运行的保障。

##### 网络负载和IO
&emsp;对于磁盘IO，我们可以用Linux下的iostat命令去查看当前IO负载的情况，比如r_wait和w_wait指标，这些指标较大则说明I/O负载较大，I/O等待比较严重，磁盘读写遇到瓶颈。这个时候我们要看压测的接口是否有文件读取和写入的操作，如果有说明接口性能瓶颈在于文件读写，这个时候可以利用文件buffer缓存API等功能进行优化，或者可以用异步的方式进行文件读写。

&emsp;对于网络负载，因为网络负载或者网络堵塞是不受控制的，这个涉及到底层的TCP通信的优化（比如利用滑动窗口和拥塞控制），这个就不展开讨论。工程师可控范围可以是选择IO读写高效率的中间件，比如redis、tomcat、activeMq、nginx、dubbo、netty等，这些中间件的底层IO模型的是多路复用IO，多路复用IO指的是一个IO线程能够服务于多个socket连接，线程监听每个连接的资源描述符。

&emsp;分布式微服务环境下，服务之间的RPC同步调用会非常频繁，随之服务之间的网络负载会影响到整个系统的服务性能，因此，每个服务的机器放置到同一个局域网下性能效果会很好。而且，对于服务之间的调用，最好利用自研或者第三方中间件去监控服务链路调用的整体情况（比如Zipkin或者SkyWalking ）,并且要合理设置服务与服务之间的超时时间，避免因为网络原因导致服务线程池耗尽，导致OOM。


###  2、中间件层
&emsp; 这里中间件，泛指数据存储层，以笔者经验来看，大多数系统性能问题和瓶颈都是与数据存储相关，这里笔者就拿这方面展开讨论总结
##### MySQL

是否有长期的事务锁占用，是否有单个资源的并发竞争。
比如投资某一个产品场景，在扣减了产品的剩余可投金额后，直接提交事务释放锁，然后利用分布式事务来做其他的耗时操作。如果其他耗时操作中有对同一资源进行竞争的话，那么产品锁持有时间过长，导致性能低。
总体来说。可以从几个方面去优化，查询效率是否高效、索引设置是否合理、SQL语句是否合理、是否用主从分摊查询压力。还比如是否用了归档，分库分表，ES引入等等
##### Redis
##### ElasticSearch


###  3、业务层方面，
拿资金匹配来说，尽量一个借款匹配一个资金，这样资金池里面的资金锁行范围会减少（因为有多线程抢占资金资源），资金匹配的速度会加快，并且这样优化这样银行转账的次数会少点，防止多个投资人账户进行银行转账，会拉长整个借款的耗时，避免其中一个账户出错导致全部回滚这样的情况。

## 三、后续流量增长系统性能优化思路
1. 利用MQ同步转异步，多线程消费
2. 读场景比较多的接口可以利用缓存redis，可以做集群、哨兵、高可用保证redis性能
3. 从产品的角度，将发布标的时间放到凌晨
4. 对于强一致的同步下单场景，可以将对MySQL的操作改为redis，然后利用MQ做异步
    - 加监控，
    - 优化JVM，比如垃圾回收器
    - 合理设置服务之间的调用超时时间
    - 非核心资金逻辑可以做异步
5. 对于架构方面，可以做MySQL主从、分库分表或者归档、Redis集群、多机房负载均衡，细化分布式部署、引入ES等多个方面考虑