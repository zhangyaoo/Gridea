---
title: '金融级业务下分布式事务保证数据一致性'
date: 2020-06-22 10:27:01
tags: [分布式事务]
published: true
hideInList: false
feature: /post-images/jin-rong-ji-ye-wu-xia-fen-bu-shi-shi-wu-bao-zheng-shu-ju-yi-zhi-xing.jpg
isTop: false
---
## 前言
> 随着分布式服务架构的流行与普及，原来在单体应用中执行的多个逻辑操作，现在被拆分成了多个服务之间的远程调用。微服务化后，随着带来的服务之间的分布式事务问题，尤其是在金融业务下，分布式事务是保证数据一致性的重要保证。本文着重会讲分布式事务场景和业界主流的解决方案。

## 一、引入
&emsp;资金转账在金融业务下是一个非常重要而且常见的场景，如果因为技术问题导致资金转账错误，导致数据不一致问题，那么就会造成无法预测的后果。
&emsp;笔者这里拿银行转账的例子来说（这里的转账有很多场景比如银行卡之间充值提现、银行账户之间的转账等等），比如甲银行账户A向乙银行账户B转账1W：

同步调用：
1. A银行对转出账户执行检查校验，进行账户金额扣减。
2. A银行同步调用B银行转账接口。
3. B银行对转入账户进行检查校验，进行账户金额增加。
4. B银行返回处理结果给A银行。
  ![](https://zhangyaoo.github.io/post-images/1593745125729.png)
同步调用问题：
*  如果B银行因为网络原因导致接口不通，那么A调用线程会长时间阻塞。
*  如果A扣减后，发送请求后，在网络中丢失了，B银行没有收到请求，导致账户A扣减了，账户B没有加
* 如果账户B扣减成功了，由于某种原因比如网络异常没有及时回调给甲银行，那么账户A就认为是异常请求，则会回滚事务，导致数据不一致。

再来看一下异步调用：
1. A银行对转出账户执行检查校验，进行账户金额扣减。
2. 主线程将请求数据异步写入队列MQ
3. 真正消费者程序对B银行进行远程调用
4. B银行对转入账户进行检查校验，进行账户金额增加。
5. B银行返回处理结果给A银行。
![](https://zhangyaoo.github.io/post-images/1593743096206.png)
异步调用问题：
* 如果账户A扣减本地事务成功了，但是消息发出后，因为网络原因或者其他宕机原因，导致消息未发送成功，没有进行B账户远程调用，导致本地事务和消息不一致性。
* MQ消费端程序如果消费消息成功，请求银行成功了，但是回传ACK给MQ失败了，那么回导致消费端程序重复消费问题，那么就会出现重复转账的问题。
* 在B账户因为某些原因导致账户增加失败，在回调A银行接口通知回滚时网络异常或者宕机，会导致A银行转账无法完成回滚，从而导致数据不一致。

异步调用解决了同步调用的主线程阻塞问题，但还是没有解决数据一致性问题。而且引入MQ中间后，还要考虑到本地事务和MQ消息一致性问题，还有其他的引入后的维护工作，比如消息丢失，消息重发等等问题。

## 二、分布式事务解决方案
&emsp;讲到了分布式事务，自然离不开分布式系统的一些基本原则和定理：CAP原则和BASE理论，相信读者应该都知道，这里不做过多阐述。业界根据这些规则和理论，衍生出了各种分布式事务解决方案：XA规范，2PC，3PC，本地消息表方案，基于消息中间件的最终一致性方案，TCC方案，阿里的SEATA，SAGA方案和最大努力通知等等。
&emsp;以上每个方案都有自己的应用场景，就拿2PC来说，MySQL的事务型日志redolog二段提交（redolog(prepare)--》binlog--》redolog(commit)）保证binlog和redolog数据一致性，Zookeeper的proposal事务二段提交（半数以上ack返回成功表示写入数据成功）保证leader和foller的数据一致性，这些都是2PC的应用。
&emsp;金融场景下类似资金业务需要保证最终一致性解决分布式事务，不需要保证转账实时性。所以本地消息表、基于MQ中间件的最终一致性等柔性方案是首选的方案。这些基于消息的分布式事务，本质上就是，本地事务+从事务，从事务从消息中获取信息进行本地提交，这里保持**异步事务机制、只能保证最终一致性**。


### 2.1 本地消息表解决一致性问题
&emsp;一般来说，跨行转账的原理，会存在一个中国人民银行的中间人角色来操作转账，但不在本次讨论的范围内。
&emsp;业界银行转账大部分都是同步转账，异步获取转账结果，包括第三方支付平台对接银行都是这样玩的。这里笔者就利用本地消息表思想来具体叙述数据一致性是如何保证的，老规矩先放图：
![](https://zhangyaoo.github.io/post-images/1603274563955.png)
其中交易记录表大概长这个样子：
|  字段   | 描述  |
|  :----:  | :----:  |
| id  | 自增ID，没有业务意义 |
| trade_order_num | 交易订单号，作为转账记录唯一标识 |
| source_account_num | 交易转出方账户ID |
| target_account_num | 交易收款方账户ID |
| status | 状态机，0=预创建，1=转账中，2=转账成功，3=转账失败 |
| create_time | 记录创建时间，可作为窗口时间内判断标准 |
| update_time | 更新时间，可追溯转账记录更新成功时间 |
账户表大概长这个样子：
|  字段   | 描述  |
|  :----:  | :----:  |
| id  | 自增ID，没有业务意义 |
| account_num | 账户ID |
| current_amt | 当前账户余额 |
| lock_amt | 冻结金额，用来记录临时状态的核心转账数据 。真实余额=current_amt-lock_amt |

图中的步骤大致分为10步，分别是：
1. 

### 2.2 事务消息解决本地事务和MQ消息一致性问题

#### 2.2.1 消费端重复消费
#### 2.2.2 消费端消费失败




### 2.3 其他问题
#### 2.3.1 银行交易冲正

## 三、 其他方式保证数据一致性
&emsp;当然，保持数据一致性不光是分布式事务来保证，业务上还要配合其他的辅助来保证，这里笔者就列举几种
1. 全链路幂等
   全链路幂等保证不产生脏数据，保护核心流程正常执行。
2. 业务对账
   业务内部准实时对账，比如业务发生后充值提现，对比用户余额是否正确，用户业务流水是否正确。
   T+1日对账，程序或者人工定时扫描核心业务数据，保证当日数据准确。对账后自动检测并且修复重试业务
3. 业务指标监控
   监控数据库中的订单预占资金没有释放，状态机是不是最终态监控，单位窗口时间内业务状态是否异常，账户中的预扣减金额是否释放，业务重试次数是否超过阈值等等业务监控。
   

## 四、总结
&emsp;分布式场景，要用分布式的思维去思考问题。要考虑任何的超时，断电，维护不同物理存储的数据的可能存在的状态不一致的场景，说白了要面向失败编程。

## 五、参考
- 有赞出金系统——https://tech.youzan.com/build-a-withdraw-sys/
- 分布式事务的思考——https://www.cnblogs.com/sujing/p/11006424.html