<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>will</title>
    <updated>2020-06-18T13:00:15.812Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>生死看淡，不服就干</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2020, will</rights>
    <entry>
        <title type="html"><![CDATA[关于系统性能瓶颈预测和系统性能优化一些思路]]></title>
        <id>http://localhost:4000/post/guan-yu-xi-tong-xing-neng-ping-jing-yu-ce-he-xi-tong-xing-neng-you-hua/</id>
        <link href="http://localhost:4000/post/guan-yu-xi-tong-xing-neng-ping-jing-yu-ce-he-xi-tong-xing-neng-you-hua/">
        </link>
        <updated>2020-06-17T13:05:11.000Z</updated>
        <content type="html"><![CDATA[<h5 id="前言">前言</h5>
<blockquote>
<p>对于任何系统，都会存在系统性能瓶颈，这里笔者作为一名Java工程师列出了自己在工作中的优化思路，仅供参考。</p>
</blockquote>
<h2 id="一-系统性能预测">一、系统性能预测</h2>
<p> 现在服务都是微服务部署开发，如果要模拟服务压测的话要在本地开启相同的服务，前提是机器配置是一样的。而且需要将线上的持久化数据同样copy到本地数据库中，这样才能真正模拟线上的环境。</p>
<p> 首先拿单台机器进行压测，压测的对象可以是某个核心的接口（这个接口可以是日志服务中统计的访问量比较高的具体的接口API），比如拿金融产品的标下单接口或者产品标的详情接口，像这种接口在某个时间会有一个高并发访问的瞬间流量。</p>
<p> 具体的指标主要是要分析系统的QPS和TPS，我们预测一个单体的应用能够承受多少的并发量，看这两个指标是否能够达到我们预期的值。后面进行压测时候，观察流量巅峰时刻观察系统的运行情况。这个就涉及到下面性能分析了.<br>
<br></p>
<h2 id="二-系统性能分析">二、系统性能分析</h2>
<h4 id="1-硬件方面">1、硬件方面：</h4>
<h5 id="cpu">CPU：</h5>
<p> 在压测的时候观察CPU的占用情况，是否长期处于100%状态，正常来说80%以下是正常的。如果非常低，那么说明系统不是在做IO密集型运算动作，性能瓶颈是在其他方面，不是在CPU上面，具体的操作方法可以用top命令查看。<br>
 以笔者经验来看，一般CPU飙高的原因无非两种，第一种就是代码中存在死循环，并且循环中有</p>
<h5 id="内存">内存：</h5>
<p>在Java中，内存是一个很重要的指标，这个关乎到系统是否可以稳定运行。我们可以借助三方工具可以查看系统的JVM内存的运行情况，笔者提供几个通用的预测内存的运行情况的思路：<br>
- 每秒占用多少内存？<br>
- 多长时间触发一次Minor GC？<br>
- 多长时间触发一次Major GC？<br>
- Minor  GC耗时多久？Major  GC耗时多久？<br>
- 会不会频繁因为Survivor放不下导致对象进入老年代？</p>
<p>在日常开发中，开发人员需要关注的就是，判断系统JVM是否有频繁FULL GC和频繁YOUNG GC，如果有，那么会严重影响系统性能。笔者就这两个方面去分析一下<br>
   1、<strong>频繁FULL GC</strong> ：首先我们应该要了解到频繁FULL GC危害，一般的中大型系统，系统的JVM会设置很大，比如会给堆内存分配4~8G的空间，因为遍历对象图的过程中堆越大，遍历时间就会长，而且如果垃圾越多，垃圾回收也会拉长整个GC的时间，这就导致每一次FULL GC会有长时间的STW，影响系统稳定性。然后我们要清楚导致触发Full GC的场景，这里列出了可能会导致的几个场景：<br>
  1）大对象<br>
  2）方法区meta space空间占满<br>
  3）年轻代的存活的生命周期长对象一直汇入老年代，导致GC<br>
  4）内存泄漏导致空间不足进而GC<br>
这里笔者就拿内存泄漏（内存泄漏指的是有引用无法被回收但是没有用的对象持续增长）来说，一般如果有内存泄漏。大概的内存监控图长这个样子<img src="http://localhost:4000/post-images/1592463486063.png" alt="" loading="lazy"><br>
这样导致的后果就是，频繁的FULL GC，最后内存一直持续增长到爆满，然后FULL GC执行间隔缩短，最终会导致GC线程持续GC，CPU使用率会直线飙升，导致系统瘫痪。<br>
    2、 <strong>频繁 YOUNG GC</strong>  ：YOUNG GC如果过于频繁的话，一般是短周期小对象较多，这时候可以从 Eden 区/新生代设置的太小了这个方面考虑，看能否通过调整-Xmn、-XX:SurvivorRatio 等参数设置来解决问题</p>
<h5 id="ioio分网络io和磁盘io">IO：IO分网络IO和磁盘IO</h5>
<p> 对于磁盘IO，我们可以用Linux下的iostat命令去查看当前IO负载的情况，比如r_wait和w_wait指标，这些指标较大则说明I/O负载较大，I/O等待比较严重，磁盘读写遇到瓶颈。这个时候我们要看压测的接口是否有文件读取和写入的操作，如果有说明接口性能瓶颈在于文件读写，这个时候可以利用文件buffer缓存API等功能进行优化，或者可以用异步的方式进行文件读写。</p>
<p> 对于网络IO，因为网络负载或者网络堵塞是不控制的，这个涉及到底层的TCP通信的优化（比如利用滑动窗口和拥塞控制），这个就不展开讨论。工程师可控范围可以是选择IO读写高效率的中间件，比如redis、tomcat、activeMq、nginx、dubbo、netty等，这些中间件的底层IO模型的是多路复用IO，多路复用IO指的是一个IO线程能够服务于多个socket连接，线程监听每个连接的资源描述符。</p>
<p> 分布式微服务环境下，服务之间的RPC同步调用会非常频繁，随之服务之间的网络负载会影响到整个系统的服务性能，因此，每个服务的机器放置到同一个局域网下性能效果会很好。而且，对于服务之间的调用，最好利用自研或者第三方中间件去监控服务链路调用的整体情况（比如Zipkin或者SkyWalking ）,并且要合理设置服务与服务之间的超时时间，避免因为网络原因导致服务线程池耗尽，导致OOM。</p>
<h4 id="2-mysql层面">2、MySQL层面</h4>
<p>，是否有长期的事务锁占用，是否有单个资源的并发竞争。<br>
比如投资某一个产品场景，在扣减了产品的剩余可投金额后，直接提交事务释放锁，然后利用分布式事务来做其他的耗时操作。如果其他耗时操作中有对同一资源进行竞争的话，那么产品锁持有时间过长，导致性能低。<br>
总体来说。可以从几个方面去优化，查询效率是否高效、索引设置是否合理、SQL语句是否合理、是否用主从分摊查询压力。还比如是否用了归档，分库分表，ES引入等等</p>
<h4 id="3-业务层方面">3、业务层方面，</h4>
<p>拿资金匹配来说，尽量一个借款匹配一个资金，这样资金池里面的资金锁行范围会减少（因为有多线程抢占资金资源），资金匹配的速度会加快，并且这样优化这样银行转账的次数会少点，防止多个投资人账户进行银行转账，会拉长整个借款的耗时，避免其中一个账户出错导致全部回滚这样的情况。</p>
<h2 id="三-系统性能优化">三、系统性能优化</h2>
<ol>
<li>利用MQ同步转异步，多线程消费</li>
<li>读场景比较多的接口可以利用缓存redis，可以做集群、哨兵、高可用保证redis性能</li>
<li>从产品的角度，将发布标的时间放到凌晨</li>
<li>对于强一致的同步下单场景，可以将对MySQL的操作改为redis，然后利用MQ做异步
<ul>
<li>加监控，</li>
<li>优化JVM，比如垃圾回收器</li>
<li>合理设置服务之间的调用超时时间</li>
<li>非核心资金逻辑可以做异步</li>
</ul>
</li>
<li>对于架构方面，可以做MySQL主从、分库分表或者归档、Redis集群、多机房负载均衡，细化分布式部署、引入ES等多个方面考虑</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[O(1)时间复杂度下，双向链表实现LRU]]></title>
        <id>http://localhost:4000/post/o1shi-jian-fu-za-du-xia-shuang-xiang-lian-biao-shi-xian-lru/</id>
        <link href="http://localhost:4000/post/o1shi-jian-fu-za-du-xia-shuang-xiang-lian-biao-shi-xian-lru/">
        </link>
        <updated>2020-06-15T11:17:45.000Z</updated>
        <content type="html"><![CDATA[<p>链表实现思路：</p>
<ul>
<li>1、数据是直接利用 HashMap 来存放的。</li>
<li>2、内部使用了一个双向链表来存放数据，所以有一个头结点 header，以及尾结点 tailer。</li>
<li>3、每次写入头结点，删除尾结点时都是依赖于 header tailer<br>
注：可以参考linkedHashMap底层结构</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1592220507945.png" alt="" loading="lazy"></figure>
<pre><code>import com.google.common.collect.Maps;
import java.util.Map;

/**
 * 线程不安全，同步机制自行控制。
 */
public class LRUCacheV2 {
    /**
     * 缓存map
     */
    private final Map&lt;String, Node&gt; cacheMap;

    /**
     * 头指针
     */
    private Node head;

    /**
     * 尾指针
     */
    private Node tail;

    /**
     * 容量
     */
    private final int cacheSize;

    /**
     * 当前容量
     */
    private int currentCacheSize;

    LRUCacheV2(int capacity){
        cacheMap = Maps.newHashMapWithExpectedSize(capacity);
        cacheSize = capacity;
        currentCacheSize = 0;
    }

    public Object get(String key){
        Node node = cacheMap.get(key);
        if(node != null){
            // 移动到头指针
            move2head(node);
            return node.getData();
        }
        return null;
    }

    public void remove(String key){
        Node node = cacheMap.get(key);
        if(node != null){
            Node pre = node.getPre();
            Node next = node.getNext();
            if(pre != null){
                pre.setNext(next);
            }
            if(next != null){
                next.setPre(pre);
            }

            // 如果删除刚好是头节点或者尾节点，也要移动指针
            if(node.getKey().equals(head.getKey())){
                head = pre;
            }
            if(node.getKey().equals(tail.getKey())){
                tail = next;
            }

            cacheMap.remove(key);
        }
    }

    public void put(String key, Object value){
        Node node = cacheMap.get(key);
        if(node != null){
            // 存在节点的话，就覆盖，并且放到头
            node.setData(value);
            move2head(node);
            cacheMap.put(key, node);
        }else {
            // 不存在节点，构造并且放到头
            if(currentCacheSize == cacheSize){
                // 删除尾node
                String delKey = tail.getKey();
                cacheMap.remove(delKey);

                // 尾指针移动
                Node next = tail.getNext();
                if(next != null){
                    next.setPre(null);
                }
                tail.setNext(null);
                tail = next;

            }else{
                currentCacheSize++;
            }
            node = new Node();
            node.setData(value);
            node.setKey(key);
            // 头指针移动
            move2head(node);
        }
        cacheMap.put(key, node);
    }

    /**
     * 节点移到头
     */
    private void move2head(Node node){
        if(head == null){
            // 初始化head 和 tail
            head = node;
            head.setNext(null);
            head.setPre(null);
            tail = node;
        }else {
            // 如果是相同的Key，啥都不用动，node就是最新的头
            if(node.getKey().equals(head.getKey())){
                return;
            }

            // 截取node
            Node pre = node.getPre();
            Node next = node.getNext();
            if(pre != null){
                pre.setNext(next);
            }
            if(next != null){
                next.setPre(pre);
            }

            // 如果要截取的节点是尾节点，那么尾节点指针也要向前移动
            if(node.getKey().equals(tail.getKey())){
                tail = next;
            }

            // 放在头前面
            head.setNext(node);
            node.setPre(head);
            // node下个指针指向null
            node.setNext(null);
            head = node;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder() ;
        Node node = head;
        while (node != null){
            sb.append(node.getKey()).append(&quot;:&quot;)
                    .append(node.getData())
                    .append(&quot;--&gt;&quot;) ;
            node = node.getPre();
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        LRUCacheV2 lruCacheV2 = new LRUCacheV2(4);
        lruCacheV2.put(&quot;1&quot;,&quot;1&quot;);
        lruCacheV2.put(&quot;2&quot;,&quot;2&quot;);
        lruCacheV2.put(&quot;3&quot;,&quot;3&quot;);
        lruCacheV2.put(&quot;4&quot;,&quot;4&quot;);
        lruCacheV2.put(&quot;5&quot;,&quot;5&quot;);
        //lruCacheV2.get(&quot;2&quot;);
        //lruCacheV2.put(&quot;2&quot;,&quot;22&quot;);
        lruCacheV2.remove(&quot;5&quot;);
        System.out.println(lruCacheV2.toString());
    }
}
</code></pre>
<p>参考：<br>
1、https://www.iteye.com/blog/gogole-692103<br>
2、https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/</p>
]]></content>
    </entry>
</feed>